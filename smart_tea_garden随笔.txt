-----2019/10/10-----
目前端口已经找好，ESP8266接到USART2上，通过ANT去控制！

接下来就是去改写master的代码，参照ESP的手册


【可以参考正点的源代码来搞】
1、使用esp之前要先检测硬件设备是否在线。
	要循环不停的检测，知道超时
2、直接进入STA 模式（终端模式）
3、选择TCP客户端，要循环检测是否连接上了
4、传输模式:透传  透明传输，方便操作




-----2019/10/11-----
1、USART表示支持同步、异步的串口通信，但是一般不使用同步，因为串口本身是异步的，就当成一个普通UART来用就行了。(使用起来完全一致)
2、串口通信底层也就是几种寄存器在操作：
	控制寄存器：负责一些配置
	状态/波特率寄存器：获取其他寄存器的状态
	数据寄存器:接收、发送数据寄存器
先配置，然后根据状态去收发。即可！！！
【从底层就是牛逼！！】
3、printf的重定向就是重写fputc函数，printf底层调用了fputc，默认标准输出，定向到串口数据寄存器就行了。

4、中断之后会进入异常处理：也就是.s文件中，处理中断，根据中断向量
   中断向量：USART2_IRQHandler

************************************************************
************************************************************
************************************************************
【先别慌着往前走呢，先把中断搞清楚了，串口 + 中断 都弄懂了，才能去搞中断方式的串口通信】
【真的是哦，之前学的一点都不牢固！！不知道为啥，就只是一股脑的学，最后啥也不懂】
***************【真的是要知其然知其所以然！！！】
***************【去做项目，凡晶事，然后什么不懂了再回来看，今天就不知不觉回来看完了串口和中断的视频，驱动着来就是好一点！！！！！】
************************************************************
************************************************************
************************************************************

中断；
1、内部中断（处理器内部产生的中断）被称为异常，外设产生的中断称为中断。
2、NVIC：嵌套向量中断控制器，中断的控制中心。
3、一般中断需要两级控制，中断源自身中断打开，NVIC的中断打开
	EXTI是GPIO的中断源控制器
4、中断和异常向量表：
	中断或异常发生时，赋给PC的地址就叫做中断/异常向量
	将异常/中断向量按照优先级排列就成了向量表
	（就是存了所有中断处理函数地址的一张表）
5、Interrupt ReQuest :IRQ  中断请求 
	一般外部中断都加这个，内部中断直接是名字
6、数字越小，优先级越高
	优先级相同，按照异常编号（就像硬排序）
7、外部中断控制器：EXTI
	1>所有GPIO都可以产生中断，但那是数字编号相同的同时只能产生一个
	  因为他们连接在同一个EXTIx上（x = 0 ~ 15）
	2>系统配置控制器（SYSCFG），管理连接到GPIO口的外部中断
8、中断/异常向量表在启动代码中！！【startup_stm32Fxx.s】
	函数入口都会列出来，和中断处理函数同名，可以直接点进去

	【寻找路线：
	先从向量表中找到函数地址，然后找到中断处理函数(一般都在stm32lxx_it.c里面)，
	  然后就根据函数的层级嵌套就可以通过F12依次找到这些函数，
	  什么所谓的执行顺序就出来了，
	  主要是第一步！！向量表哇，我以前咋一点印象都没有呢？？】
9、无论用什么库来实现，都是需要以下步骤：
	使能时钟
	配置GPIO管脚中断功能
	设置中断优先级
	使能相应的中断
	实现中断服务程序，一般主要实现回调函数，因为他是weak的，可以直接重写
	【如果使用CubeMX的话，主要就是写回调函数，其他的直接图形化操作】

10、中断接收函数要接收到指定的数量的字符，否则是不会产生中断的
11、串口中断需要触发才能进入回调函数，
	触发函数为：HAL_UART_Receive_IT
	HAL_UART_Transmit_IT
	【触发一次后要再次调用才能再次进入回调函数，一次性的】
	
********************************
OK了，也算是把中断又过了一遍，更熟悉了吧。。。
*******************************


-----2019/10/12-----
1、串口的执行过程探究：
中断向量找到中断函数：USART2_IRQHandler
-->然后进入HAL_UART_IRQHandler(执行一系列置位，判断操作) 
-->进入UART_Receive_IT函数，配置操作
   最后转向HAL_UART_RxCpltCallback函数
【没有加串口号标识的都需要通过串口结构体来判断】


2、正点的串口接收处理函数用的都是定时器，HAL也是
	暂时不与参考！！！

	先把串口实现，然后再参考他的ESP通信流程
	串口收发字符串先搞定。


现在就是把串口搞好！！！
深挖串口通信！！！
趁这次机会把串口搞透彻！！！


3、最终解决bug， 问题不是出现在串口上，是自己的变量num和flag判断错了！！
	debug总结：
		理性的去分析问题，而不是乱改乱试！！
		分析代码，输出结果，看是哪一个部分出问题了！！！
	然而最后并没有用到这两个变量。。。。


AT+CWJAP="AlbusInk","AlbusInk"
AT+CIPSTART="TCP","192.168.43.125",12345


4、出问题了

1---
AT+RST返回的值中有ready，但是是不是一次性发过来的！！
(就我现在写的代码而言：只能是发送一次，接收一次，后面几次返回的值是无法获取的)
要想从多次返回的数据中找到ready子串，怎么搞？？？
其他命令也是，都需要，最好都通过循环来配置
用strstr找子串，不错
A: 不是一次性发过来的，那就看第一次发过来的数据中有什么标志子串，检测是否有该子串就行了，后面的数据丢了就丢了，反正是自动配置搞的鬼

2---
还有最后透传的时候，要一直保持接收发送的状态，通过现有的那个send_cmd函数是不行的，要一直保持接收


这两个问题能统一解决吗？？？


now
现在通过笨拙的方式：直接发送不管返回的值，直接连接，已经可以进入透传模式了，但是这样总是不行的，这样就相当于send_cmd函数没有用到

需要解决以上两个问题(逻辑问题了，不是没学过的问题了！！)

最终状态：
1-无限循环来配置参数
2-完成透传功能

*********************************
真的是需要先从大局入手啊，先把框架搭好在实现代码，否则，处处碰壁，处处踩坑


大局观！！！！
先搭框架，再实现代码，实现代码就是没有太大技术含量的事了！！！！
不要以为一上来就敲代码很充实，敲着代码很爽，然而bug层出不穷！！！！

编程中敲代码只是一小部分，主要是前面的需求分析，实现步骤/框架的搭建！！
先画框图！！！


-----2019/10/13-----
看来串口这次真的要好好搞一下了，彻底给他搞清楚了：
	1、实现原理
	2、串口通信的几种方式（应用




-----2019/10/16-----
已经成功的配置好ubuntu的stm32的环境了，明天就可以开始开发了


-----2019/10/17-----
目前还需要：
1、配置vsCode，用来编写代码，当作编辑器   OK
2、研究makeflie文件，将win那个代码移植过来
	正在配置，暂时没有其他报错了，只是makefile还有点问题
	需要把nakefile解读一遍，然后再该，杜绝怀着侥幸心理瞎改！！！！
3、继续开始画框架图--思维导图上
















